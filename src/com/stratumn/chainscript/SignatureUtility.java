package com.stratumn.chainscript;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.util.Base64;

import org.apache.commons.lang3.StringUtils;

import com.google.protobuf.ByteString;

import net.i2p.crypto.eddsa.EdDSAPrivateKey;


public class SignatureUtility
{
   /**
    * Convert a plain object to a signature.
    * @param s plain object.
    */
   public static Signature fromObject(stratumn.chainscript.Chainscript.Signature signature)
   {
      if(signature.getSignature().isValidUtf8())
      {
         byte[] sigBytes = Base64.getDecoder().decode(signature.getSignature().toByteArray());
         signature.toBuilder().setSignature(ByteString.copyFrom(sigBytes)).build();
      }

      if(signature.getPublicKey().isValidUtf8())
      {
         byte[] publicKeyBytes = Base64.getDecoder().decode(signature.getPublicKey().toByteArray());
         signature.toBuilder().setPublicKey(ByteString.copyFrom(publicKeyBytes)).build();
      }
      return new Signature(signature);
   }

   /**
    * Sign bytes with the current signature version.
    * @param key private key in PEM format (generated by @stratumn/js-crypto).
    * @param toSign bytes that should be signed.
    * @throws Exception 
    */
   public static Signature sign(byte[] key, byte[] toSign) throws Exception
   {
      String signature;
      try
      {
         EdDSAPrivateKey privateKey = CryptoUtils.decodeEd25519PrivateKey(new String(key));
         signature = CryptoUtils.sign(privateKey, toSign);
      }
      catch(InvalidKeyException | NoSuchAlgorithmException | SignatureException | InvalidKeySpecException e)
      {
         throw new Exception("Could not create the private key / signature");
      }

      stratumn.chainscript.Chainscript.Signature sig =
         stratumn.chainscript.Chainscript.Signature.newBuilder().setVersion(Constants.SIGNATURE_VERSION).setSignature(ByteString.copyFrom(signature.getBytes())).build();
    
      return new Signature(sig);
   }

   /**
    * Sign configurable parts of the given link with the current signature
    * version.
    * The payloadPath is used to select what parts of the link need to be signed
    * with the given private key. If no payloadPath is provided, the whole link
    * is signed.
    * @param key private key in PEM format (generated by @stratumn/js-crypto).
    * @param link that should be signed.
    * @param payloadPath link parts that should be signed.
    * @throws Exception 
    */
   public static Signature signLink(byte[] key, Link link, String payloadPath) throws Exception
   {
      // We want to make it explicit when we're signing the whole link.
      if(StringUtils.isEmpty(payloadPath))
      {
         payloadPath = "[version,data,meta]";
      }
      byte[] toSign = link.signedBytes(Constants.SIGNATURE_VERSION, payloadPath);
      Signature signature = sign(key, toSign);

      stratumn.chainscript.Chainscript.Signature sig = stratumn.chainscript.Chainscript.Signature.newBuilder().setVersion(signature.version()).setPayloadPath(payloadPath)
         .setPublicKey(signature.publicKey()).setSignature(signature.signature()).build();

      return new Signature(sig);
   }

}
